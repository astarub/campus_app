#private Appwrite dummy interface for updating user local data 

import fs from 'node:fs/promises';
import path from 'node:path';
import crypto from 'node:crypto';
import url from 'node:url';
import { Client, Storage, ID, Permission, Role, Query } from 'node-appwrite';
import dotenv from 'dotenv';
dotenv.config();

const client = new Client()
  .setEndpoint(process.env.APPWRITE_ENDPOINT)
  .setProject(process.env.APPWRITE_PROJECT_ID)
  .setKey(process.env.APPWRITE_KEY);

const storage = new Storage(client);
const bucketId = 'maps';
const GRAPH = 'graph.json';

async function ensureBucket() {
  try {
    await storage.getBucket(bucketId);
  } catch {
    await storage.createBucket(
      ID.custom(bucketId),
      bucketId,
      [Permission.read(Role.any())],
      false,
      'default'
    );
  }
}

const __dirname = path.dirname(url.fileURLToPath(import.meta.url));
const mapsDir = path.join(__dirname, 'maps');

async function fileSha256(fp) {
  const data = await fs.readFile(fp);
  return crypto.createHash('sha256').update(data).digest('hex');
}

async function sync() {
  await ensureBucket();

  const localJpgs = (await fs.readdir(mapsDir)).filter(f =>
    f.toLowerCase().endsWith('.jpg')
  );
  const localFiles = new Map(
    localJpgs.map(f => [f, path.join(mapsDir, f)])
  );

  const graphPath = path.join(__dirname, GRAPH);
  if (!(await exists(graphPath))) throw new Error(`Missing ${GRAPH} in project root`);
  localFiles.set(GRAPH, graphPath);

  const remote = await storage.listFiles(bucketId, [Query.limit(1000)]);
  const remoteMap = new Map(remote.files.map(f => [f.name, f]));

  for (const [name, fp] of localFiles) {
    const buffer = await fs.readFile(fp);

    if (remoteMap.has(name)) {
      const remoteFile = remoteMap.get(name);
      const localHash = await fileSha256(fp);
      if (remoteFile.hash !== localHash) {
        await storage.updateFile(bucketId, remoteFile.$id, name, buffer);
      }
      remoteMap.delete(name);
    } else {
      await storage.createFile(bucketId, ID.unique(), name, buffer);
    }
  }

  for (const stray of remoteMap.values()) {
    await storage.deleteFile(bucketId, stray.$id);
  }
}

async function exists(fp) {
  try {
    await fs.access(fp);
    return true;
  } catch {
    return false;
  }
}

sync().catch(err => {
  console.error('sync failed:', err.message ?? err);
  process.exit(1);
});
